<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>VIM: terminal</title>
<link rel="stylesheet" href="vim-stylesheet.css" type="text/css">
</head>
<body>
<h2>TERMINAL</h2>
<pre>
<b class="vimtag">*<a name="terminal.txt">terminal.txt</a>*</b>	For Vim version 8.0.  Last change: 2018 Feb 20


		  VIM REFERENCE MANUAL	  by Bram Moolenaar


Terminal window support					<b class="vimtag">*<a name="terminal">terminal</a>*</b>


The terminal feature is optional, use this to check if your Vim has it:
<code class="example">	echo has('terminal')</code>
If the result is "1" you have it.


1. Basic use			|<a href="terminal.html#terminal-use">terminal-use</a>|
      Typing				|<a href="terminal.html#terminal-typing">terminal-typing</a>|
      Size and color			|<a href="terminal.html#terminal-size-color">terminal-size-color</a>|
      Syntax				|<a href="terminal.html#:terminal">:terminal</a>|
      Resizing				|<a href="terminal.html#terminal-resizing">terminal-resizing</a>|
      Terminal Modes			|<a href="terminal.html#Terminal-mode">Terminal-mode</a>|
      Cursor style			|<a href="terminal.html#terminal-cursor-style">terminal-cursor-style</a>|
      Special keys			|<a href="terminal.html#terminal-special-keys">terminal-special-keys</a>|
      Unix				|<a href="terminal.html#terminal-unix">terminal-unix</a>|
      MS-Windows			|<a href="terminal.html#terminal-ms-windows">terminal-ms-windows</a>|
2. Remote testing		|<a href="terminal.html#terminal-testing">terminal-testing</a>|
3. Diffing screen dumps		|<a href="terminal.html#terminal-diff">terminal-diff</a>|
      Writing a screen dump test for Vim  |<a href="terminal.html#terminal-dumptest">terminal-dumptest</a>|
      Creating a screen dump		  |<a href="terminal.html#terminal-screendump">terminal-screendump</a>|
      Comparing screen dumps		  |<a href="terminal.html#terminal-diffscreendump">terminal-diffscreendump</a>|
4. Debugging			|<a href="terminal.html#terminal-debug">terminal-debug</a>|
      Starting				|<a href="terminal.html#termdebug-starting">termdebug-starting</a>|
      Example session			|<a href="terminal.html#termdebug-example">termdebug-example</a>|
      Stepping through code		|<a href="terminal.html#termdebug-stepping">termdebug-stepping</a>|
      Inspecting variables		|<a href="terminal.html#termdebug-variables">termdebug-variables</a>|
      Other commands			|<a href="terminal.html#termdebug-commands">termdebug-commands</a>|
      Communication			|<a href="terminal.html#termdebug-communication">termdebug-communication</a>|
      Customizing			|<a href="terminal.html#termdebug-customizing">termdebug-customizing</a>|

<code class="special">{Vi does not have any of these commands}</code>
{only available when compiled with the |<a href="various.html#+terminal">+terminal</a>| feature}
The terminal feature requires the |<a href="various.html#+multi_byte">+multi_byte</a>|, |<a href="various.html#+job">+job</a>| and |<a href="various.html#+channel">+channel</a>| features.

</pre><hr><pre>1. Basic use						<b class="vimtag">*<a name="terminal-use">terminal-use</a>*</b>

This feature is for running a terminal emulator in a Vim window.  A job can be
started connected to the terminal emulator. For example, to run a shell:
<code class="example">     :term bash</code>
<code class="example"></code>
Or to run build command:
<code class="example">     :term make myprogram</code>
<code class="example"></code>
The job runs asynchronously from Vim, the window will be updated to show
output from the job, also while editing in another window.


<code class="section">Typing </code>
							<b class="vimtag">*<a name="terminal-typing">terminal-typing</a>*</b>
When the keyboard focus is in the terminal window, typed keys will be sent to
the job.  This uses a pty when possible.  You can click outside of the
terminal window to move keyboard focus elsewhere.

<code class="keystroke">CTRL-W</code> can be used to navigate between windows and other <code class="keystroke">CTRL-W</code> commands, e.g.:
	<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-W</code>	move focus to the next window
	<code class="keystroke">CTRL-W</code> :	enter an Ex command
See |<a href="index.html#CTRL-W">CTRL-W</a>| for more commands.

Special in the terminal window:			<b class="vimtag">*<a name="CTRL-W_.">CTRL-W_.</a>*</b>  <b class="vimtag">*<a name="CTRL-W_N">CTRL-W_N</a>*</b>
	<code class="keystroke">CTRL-W</code> .	send a <code class="keystroke">CTRL-W</code> to the job in the terminal
	<code class="keystroke">CTRL-W</code> N	go to Terminal-Normal mode, see |<a href="terminal.html#Terminal-mode">Terminal-mode</a>|
	CTRL-\ <code class="keystroke">CTRL-N</code>   go to Terminal-Normal mode, see |<a href="terminal.html#Terminal-mode">Terminal-mode</a>|
	<code class="keystroke">CTRL-W</code> " <code class="special">{reg}</code>  paste register <code class="special">{reg}</code>		<b class="vimtag">*<a name="CTRL-W_quote">CTRL-W_quote</a>*</b>
			Also works with the = register to insert the result of
			evaluating an expression.
	<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-C</code>	ends the job, see below |<a href="terminal.html#t_CTRL-W_CTRL-C">t_CTRL-W_CTRL-C</a>|

See option 'termkey' for specifying another key instead of <code class="keystroke">CTRL-W</code> that
will work like <code class="keystroke">CTRL-W</code>.  However, typing 'termkey' twice sends 'termkey' to
the job.  For example:
	'termkey' <code class="keystroke">CTRL-W</code>    move focus to the next window
	'termkey' :	    enter an Ex command
	'termkey' 'termkey' send 'termkey' to the job in the terminal
	'termkey' .	    send a <code class="keystroke">CTRL-W</code> to the job in the terminal
	'termkey' N	    go to terminal Normal mode, see below
	'termkey' <code class="keystroke">CTRL-N</code>    same as <code class="keystroke">CTRL-W</code> N
	'termkey' <code class="keystroke">CTRL-C</code>    same as |<a href="terminal.html#t_CTRL-W_CTRL-C">t_CTRL-W_CTRL-C</a>|
							<b class="vimtag">*<a name="t_CTRL-\_CTRL-N">t_CTRL-\_CTRL-N</a>*</b>
The special key combination CTRL-\ <code class="keystroke">CTRL-N</code> can be used to switch to Normal
mode, just like this works in any other mode.
							<b class="vimtag">*<a name="t_CTRL-W_CTRL-C">t_CTRL-W_CTRL-C</a>*</b>
<code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-C</code> can be typed to forcefully end the job.  On MS-Windows a
<code class="keystroke">CTRL-BREAK</code> will also kill the job.

If you type <code class="keystroke">CTRL-C</code> the effect depends on what the pty has been configured to
do.  For simple commands this causes a SIGINT to be sent to the job, which
would end it.  Other commands may ignore the SIGINT or handle the <code class="keystroke">CTRL-C</code>
themselves (like Vim does).

To change the keys you type use terminal mode mappings, see |<a href="map.html#:tmap">:tmap</a>|.
These are defined like any mapping, but apply only when typing keys that are
sent to the job running in the terminal.  For example, to make Escape switch
to Terminal-Normal mode:
<code class="example">   tnoremap <code class="special">&lt;Esc&gt;</code> <code class="special">&lt;C-W&gt;</code>N</code>
							<b class="vimtag">*<a name="options-in-terminal">options-in-terminal</a>*</b>
After opening the terminal window and setting 'buftype' to "terminal" the
BufWinEnter autocommand event is triggered.  This makes it possible to set
options specifically for the window and buffer.  Example:
<code class="example">   au BufWinEnter * if &amp;buftype == 'terminal' |<code class="badlink"> setlocal bufhidden=hide </code>| endif</code>
<code class="example"></code>
Mouse events (click and drag) are passed to the terminal.  Mouse move events
are only passed when Vim itself is receiving them.  For a terminal that is
when 'balloonevalterm' is enabled.


<code class="section">Size and color </code>
							<b class="vimtag">*<a name="terminal-size-color">terminal-size-color</a>*</b>
See option 'termsize' for controlling the size of the terminal window.
(TODO: scrolling when the terminal is larger than the window)

The job running in the terminal can change the colors.  The default foreground
and background colors are taken from Vim, the Normal highlight group.

For a color terminal the 'background' option is used to decide whether the
terminal window will start with a white or black background.

To use a different color the Terminal highlight group can be used, for
example:
<code class="example">    hi Terminal ctermbg=lightgrey ctermfg=blue guibg=lightgrey guifg=blue</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Syntax </code>

:<code class="special">[range]</code>ter[minal] [options] [command]			<b class="vimtag">*<a name=":ter">:ter</a>*</b> <b class="vimtag">*<a name=":terminal">:terminal</a>*</b>
			Open a new terminal window.

			If [command] is provided run it as a job and connect
			the input and output to the terminal.
			If [command] is not given the 'shell' option is used.
			if [command] is NONE no job is started, the pty of the
			terminal can be used by a command like gdb.

			A new buffer will be created, using [command] or
			'shell' as the name, prefixed with a "!".  If a buffer
			by this name already exists a number is added in
			parentheses.  E.g. if "gdb" exists the second terminal
			buffer will use "!gdb (1)".

			If <code class="special">[range]</code> is given the specified lines are used as
			input for the job.  It will not be possible to type
			keys in the terminal window.  For MS-Windows see the
			++eof argument below.

						<b class="vimtag">*<a name="term++close">term++close</a>*</b> <b class="vimtag">*<a name="term++open">term++open</a>*</b>
			Supported [options] are:
			++close		The terminal window will close
					automatically when the job terminates.
			++open		When the job terminates and no window
					shows it, a window will be opened.
					<code class="note">Note</code> that this can be interruptive.
			++curwin	Open the terminal in the current
					window, do not split the current
					window.  Fails if the current buffer
					cannot be |<a href="editing.html#abandon">abandon</a>|ed.
			++hidden	Open the terminal in a hidden buffer,
					no window will be used.
			++rows=<code class="special">{height}</code> Use <code class="special">{height}</code> for the terminal window
					height.  If the terminal uses the full
					Vim height (no window above or below
					th terminal window) the command line
					height will be reduced as needed.
			++cols=<code class="special">{width}</code>  Use <code class="special">{width}</code> for the terminal window
					width. If the terminal uses the full
					Vim width (no window left or right of
					the terminal window) this value is
					ignored.
			++eof=<code class="special">{text}</code>	when using <code class="special">[range]</code>: text to send after
					the last line was written. Cannot
					contain white space.  A CR is
					appended.  For MS-Windows the default
					is to send <code class="keystroke">CTRL-D</code>.
					E.g. for a shell use "++eof=exit" and
					for Python "++eof=exit()".  Special
					codes can be used like with `:map`,
					e.g. "<code class="special">&lt;C-Z&gt;</code>" for <code class="keystroke">CTRL-Z</code>.

			If you want to use more options use the |<a href="eval.html#term_start()">term_start()</a>|
			function.

When the buffer associated with the terminal is unloaded or wiped out the job
is killed, similar to calling `job_stop(job, "kill")`

So long as the job is running the window behaves like it contains a modified
buffer.  Trying to close the window with `<code class="keystroke">CTRL-W</code> :quit` fails.  When using
`<code class="keystroke">CTRL-W</code> :quit!` the job is ended.  The text in the window is lost.  The buffer
still exists, but getting it in a window with `:buffer` will show an empty
buffer.

Trying to close the window with `<code class="keystroke">CTRL-W</code> :close` also fails.   Using
`<code class="keystroke">CTRL-W</code> :close!` will close the window and make the buffer hidden.

You can use `<code class="keystroke">CTRL-W</code> :hide` to close the terminal window and make the buffer
hidden, the job keeps running.  The `:buffer` command can be used to turn the
current window into a terminal window.  If there are unsaved changes this
fails, use !  to force, as usual.

To have a background job run without a window, and open the window when it's
done, use options like this:
<code class="example">	:term ++hidden ++open make</code>
<code class="note">Note</code> that the window will open at an unexpected moment, this will interrupt
what you are doing.

							<b class="vimtag">*<a name="E947">E947</a>*</b> <b class="vimtag">*<a name="E948">E948</a>*</b>
So long as the job is running, the buffer is considered modified and Vim
cannot be quit easily, see |<a href="editing.html#abandon">abandon</a>|.

When the job has finished and no changes were made to the buffer: closing the
window will wipe out the buffer.

Before changes can be made to a terminal buffer, the 'modifiable' option must
be set.  This is only possible when the job has finished.  At the first change
the buffer will become a normal buffer and the highlighting is removed.
You may want to change the buffer name with |<a href="editing.html#:file">:file</a>| to be able to write, since
the buffer name will still be set to the command.


<code class="section">Resizing </code>
							<b class="vimtag">*<a name="terminal-resizing">terminal-resizing</a>*</b>
The size of the terminal can be in one of three modes:

1. The 'termsize' option is empty: The terminal size follows the window size.
   The minimal size is 2 screen lines with 10 cells.

2. The 'termsize' option is "rows*cols", where "rows" is the minimal number of
   screen rows and "cols" is the minimal number of cells.

3. The 'termsize' option is "rowsXcols" (where the x is upper or lower case).
   The terminal size is fixed to the specified number of screen lines and
   cells.  If the window is bigger there will be unused empty space.

If the window is smaller than the terminal size, only part of the terminal can
be seen (the lower-left part).

The |<a href="eval.html#term_getsize()">term_getsize()</a>| function can be used to get the current size of the
terminal.  |<a href="eval.html#term_setsize()">term_setsize()</a>| can be used only when in the first or second mode,
not when 'termsize' is "rowsXcols".


<code class="section">Terminal-Job and Terminal-Normal mode </code>
							<b class="vimtag">*<a name="Terminal-mode">Terminal-mode</a>*</b>
When the job is running the contents of the terminal is under control of the
job.  That includes the cursor position.  Typed keys are sent to the job.
The terminal contents can change at any time.  This is called Terminal-Job
mode.

Use <code class="keystroke">CTRL-W</code> N (or 'termkey' N) to switch to Terminal-Normal mode.  Now the
contents of the terminal window is under control of Vim, the job output is
suspended.  CTRL-\ <code class="keystroke">CTRL-N</code> does the same.

Terminal-Job mode is where |<a href="map.html#:tmap">:tmap</a>| mappings are applied. Keys sent by
|<a href="eval.html#term_sendkeys()">term_sendkeys()</a>| are not subject to tmap, but keys from |<a href="eval.html#feedkeys()">feedkeys()</a>| are.

							<b class="vimtag">*<a name="E946">E946</a>*</b>
In Terminal-Normal mode you can move the cursor around with the usual Vim
commands, Visually mark text, yank text, etc.  But you cannot change the
contents of the buffer.  The commands that would start insert mode, such as
'i' and 'a', return to Terminal-Job mode.  The window will be updated to show
the contents of the terminal. |<a href="insert.html#:startinsert">:startinsert</a>| is ineffective.

In Terminal-Normal mode the statusline and window title show "(Terminal)".  If
the job ends while in Terminal-Normal mode this changes to
"(Terminal-finished)".

It is not possible to enter Insert mode from Terminal-Job mode.


<code class="section">Cursor style </code>
							<b class="vimtag">*<a name="terminal-cursor-style">terminal-cursor-style</a>*</b>
By default the cursor in the terminal window uses a not blinking block.  The
normal xterm escape sequences can be used to change the blinking state and the
shape.  Once focus leaves the terminal window Vim will restore the original
cursor.

An exception is when xterm is started with the "-bc" argument, or another way
that causes the cursor to blink.  This actually means that the blinking flag
is inverted.  Since Vim cannot detect this, the terminal window cursor
blinking will also be inverted.


<code class="section">Special keys </code>
							<b class="vimtag">*<a name="terminal-special-keys">terminal-special-keys</a>*</b>
Since the terminal emulator simulates an xterm, only escape sequences that
both Vim and xterm recognize will be available in the terminal window.  If you
want to pass on other escape sequences to the job running in the terminal you
need to set up forwarding.  Example:
<code class="example">	tmap <code class="special">&lt;expr&gt;</code> <code class="special">&lt;Esc&gt;</code>]b SendToTerm("\<code class="special">&lt;Esc&gt;</code>]b")</code>
<code class="example">	func SendToTerm(what)</code>
<code class="example">	  call term_sendkeys('', a:what)</code>
<code class="example">	  return ''</code>
<code class="example">	endfunc</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Unix </code>
							<b class="vimtag">*<a name="terminal-unix">terminal-unix</a>*</b>
On Unix a pty is used to make it possible to run all kinds of commands.  You
can even run Vim in the terminal!  That's used for debugging, see below.

Environment variables are used to pass information to the running job:
    TERM		name of the terminal, 'term'
    ROWS		number of rows in the terminal initially
    LINES		same as ROWS
    COLUMNS		number of columns in the terminal initially
    COLORS		number of colors, 't_Co' (256<b class="vimtag">*<a name="256">256</a>*</b>256 in the GUI)
    VIM_SERVERNAME	v:servername

The |<a href="remote.html#client-server">client-server</a>| feature can be used to communicate with the Vim instance
where the job was started.  This only works when v:servername is not empty.
If needed you can set it with:
<code class="example">	call remote_startserver('vim-server')</code>
<code class="example"></code>
In the job you can then do something like:
<code class="example">	vim --servername $VIM_SERVERNAME --remote +123 some_file.c</code>
This will open the file "some_file.c" and put the cursor on line 123.


<code class="section">MS-Windows </code>
							<b class="vimtag">*<a name="terminal-ms-windows">terminal-ms-windows</a>*</b>
On MS-Windows winpty is used to make it possible to run all kind of commands.
Obviously, they must be commands that run in a terminal, not open their own
window.

You need the following two files from winpty:

    winpty.dll
    winpty-agent.exe

You can download them from the following page:

    https://github.com/rprichard/winpty

Just put the files somewhere in your PATH.  You can set the 'winptydll' option
to point to the right file, if needed.  If you have both the 32-bit and 64-bit
version, rename to winpty32.dll and winpty64.dll to match the way Vim was
build.

Environment variables are used to pass information to the running job:
    VIM_SERVERNAME	v:servername

</pre><hr><pre>2. Remote testing					<b class="vimtag">*<a name="terminal-testing">terminal-testing</a>*</b>

Most Vim tests execute a script inside Vim.  For some tests this does not
work, running the test interferes with the code being tested.  To avoid this
Vim is executed in a terminal window.  The test sends keystrokes to it and
inspects the resulting screen state.

<code class="section">Functions </code>

term_sendkeys()		send keystrokes to a terminal (not subject to tmap)
term_wait()		wait for screen to be updated
term_scrape()		inspect terminal screen


</pre><hr><pre>3. Diffing screen dumps					<b class="vimtag">*<a name="terminal-diff">terminal-diff</a>*</b>

In some cases it can be bothersome to test that Vim displays the right
characters on the screen.  E.g. with syntax highlighting.  To make this
simpler it is possible to take a screen dump of a terminal and compare it to
an expected screen dump.

Vim uses the window size, text, color and other attributes as displayed.  The
Vim screen size, font and other properties do not matter.  Therefore this
mechanism is portable across systems.  A convential screenshot would reflect
all differences, including font size and family.


<code class="section">Writing a screen dump test for Vim </code>
							<b class="vimtag">*<a name="terminal-dumptest">terminal-dumptest</a>*</b>
For an example see the Test_syntax_c() function in
src/testdir/test_syntax.vim.  The main parts are:
- Write a file you want to test with. This is useful for testing syntax
  highlighting.  You can also start Vim with en empty buffer.
- Run Vim in a terminal with a specific size.  The default is 20 lines of 75
  characters.  This makes sure the dump is always this size.  The function
  RunVimInTerminal() takes care of this.  Pass it the arguments for the Vim
  command.
- Send any commands to Vim using term_sendkeys().  For example:
<code class="example">	call term_sendkeys(buf, ":echo &amp;lines &amp;columns\<code class="special">&lt;CR&gt;</code>")</code>
- Check that the screen is now in the expected state, using
  VerifyScreenDump().  This expects the reference screen dump to be in the
  src/testdir/dumps/ directory.  Pass the name without ".dump".  It is
  recommended to use the name of the test function and a sequence number, so
  that we know what test is using the file.
- Repeat sending commands and checking the state.
- Finally stop Vim by calling StopVimInTerminal().

The first time you do this you won't have a screen dump yet.  Create an empty
file for now, e.g.:
<code class="example">	touch src/testdir/dumps/Test_function_name_01.dump</code>
<code class="example"></code>
The test will then fail, giving you the command to compare the reference dump
and the failed dump, e.g.:
<code class="example">	call term_dumpdiff("Test_func.dump.failed", "dumps/Test_func.dump")</code>
<code class="example"></code>
Use this command in Vim, with the current directory set to src/testdir.
Once you are satisfied with the test, move the failed dump in place of the
reference:
<code class="example">	:!mv Test_func.dump.failed dumps/Test_func.dump</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Creating a screen dump </code>
							<b class="vimtag">*<a name="terminal-screendump">terminal-screendump</a>*</b>

To create the screen dump, run Vim (or any other program) in a terminal and
make it show the desired state.  Then use the term_dumpwrite() function to
create a screen dump file.  For example:
<code class="example">	:call term_dumpwrite(77, "mysyntax.dump")</code>
<code class="example"></code>
Here "77" is the buffer number of the terminal.  Use `:ls!` to see it.

You can view the screen dump with term_dumpload():
<code class="example">	:call term_dumpload("mysyntax.dump")</code>
<code class="example"></code>
To verify that Vim still shows exactly the same screen, run Vim again with
exactly the same way to show the desired state.  Then create a screen dump
again, using a different file name:
<code class="example">	:call term_dumpwrite(88, "test.dump")</code>
<code class="example"></code>
To assert that the files are exactly the same use assert_equalfile():
<code class="example">	call assert_equalfile("mysyntax.dump", "test.dump")</code>
<code class="example"></code>
If there are differences then v:errors will contain the error message.


<code class="section">Comparing screen dumps </code>
						<b class="vimtag">*<a name="terminal-diffscreendump">terminal-diffscreendump</a>*</b>

assert_equalfile() does not make it easy to see what is different.
To spot the problem use term_dumpdiff():
<code class="example">	call term_dumpdiff("mysyntax.dump", "test.dump")</code>
<code class="example"></code>
This will open a window consisting of three parts:
1.  The contents of the first dump
2.  The difference between the first and second dump
3.  The contents of the second dump

You can usually see what differs in the second part.  Use the 'ruler' to
relate it to the postion in the first or second dump.

Alternatively, press "s" to swap the first and second dump. Do this everal
times so that you can spot the difference in the context of the text.

</pre><hr><pre>4. Debugging						<b class="vimtag">*<a name="terminal-debug">terminal-debug</a>*</b>

The Terminal debugging plugin can be used to debug a program with gdb and view
the source code in a Vim window.  Since this is completely contained inside
Vim this also works remotely over an ssh connection.


<code class="section">Starting </code>
							<b class="vimtag">*<a name="termdebug-starting">termdebug-starting</a>*</b>
Load the plugin with this command:
<code class="example">	packadd termdebug</code>
							<b class="vimtag">*<a name=":Termdebug">:Termdebug</a>*</b>
To start debugging use `:Termdebug` followed by the command name, for example:
<code class="example">	:Termdebug vim</code>
<code class="example"></code>
This opens two windows:

gdb window	A terminal window in which "gdb vim" is executed.  Here you
		can directly interact with gdb.  The buffer name is "!gdb".

program window	A terminal window for the executed program.  When "run" is
		used in gdb the program I/O will happen in this window, so
		that it does not interfere with controlling gdb.  The buffer
		name is "gdb program".

The current window is used to show the source code.  When gdb pauses the
source file location will be displayed, if possible.  A sign is used to
highlight the current position, using highlight group debugPC.

If the buffer in the current window is modified, another window will be opened
to display the current gdb position.

Focus the terminal of the executed program to interact with it.  This works
the same as any command running in a terminal window.

When the debugger ends, typically by typing "quit" in the gdb window, the two
opened windows are closed.


<code class="section">Example session </code>
							<b class="vimtag">*<a name="termdebug-example">termdebug-example</a>*</b>
Start in the Vim "src" directory and build Vim:
<code class="example">	% make</code>
Start Vim:
<code class="example">	% ./vim</code>
Load the termdebug plugin and start debugging Vim:
<code class="example">	:packadd termdebug</code>
<code class="example">	:Termdebug vim</code>
You should now have three windows:
    source  - where you started, has a window toolbar with buttons
    gdb	    - you can type gdb commands here
    program - the executed program will use this window

You can use <code class="keystroke">CTRL-W</code> <code class="keystroke">CTRL-W</code> or the mouse to move focus between windows.
Put focus on the gdb window and type:
<code class="example">	break ex_help</code>
<code class="example">	run</code>
Vim will start running in the program window. Put focus there and type:
<code class="example">	:help gui</code>
Gdb will run into the ex_help breakpoint.  The source window now shows the
ex_cmds.c file.  A "&gt;&gt;" marker will appear where the breakpoint was set.  The
line where the debugger stopped is highlighted.  You can now step through the
program.  Let's use the mouse: click on the "Next" button in the window
toolbar.  You will see the highlighting move as the debugger executes a line
of source code.

Click "Next" a few times until the for loop is highlighted.  Put the cursor on
the end of "eap-&gt;arg", then click "Eval" in the toolbar.  You will see this
displayed:
<code class="section">	"eap-&gt;arg": 0x555555e68855 "gui" </code>
This way you can inspect the value of local variables.  You can also focus the
gdb window and use a "print" command, e.g.:
<code class="example">	print *eap</code>
If mouse pointer movements are working, Vim will also show a balloon when the
mouse rests on text that can be evaluated by gdb.

Now go back to the source window and put the cursor on the first line after
the for loop, then type:
<code class="example">	:Break</code>
You will see a "&gt;&gt;" marker appear, this indicates the new breakpoint.  Now
click "Cont" in the toolbar and the code until the breakpoint will be
executed.

You can type more advanced commands in the gdb window.  For example, type:
<code class="example">	watch curbuf</code>
Now click "Cont" in the toolbar (or type "cont" in the gdb window). Execution
will now continue until the value of "curbuf" changes, which is in do_ecmd().
To remove this watchpoint again type in the gdb window:
<code class="example">	delete 3</code>
<code class="example"></code>
You can see the stack by typing in the gdb window:
<code class="example">	where</code>
Move through the stack frames, e.g. with:
<code class="example">	frame 3</code>
The source window will show the code, at the point where the call was made to
a deeper level.


<code class="section">Stepping through code </code>
							<b class="vimtag">*<a name="termdebug-stepping">termdebug-stepping</a>*</b>
Put focus on the gdb window to type commands there.  Some common ones are:
- <code class="keystroke">CTRL-C</code>	interrupt the program
- next		execute the current line and stop at the next line
- step		execute the current line and stop at the next statement,
		entering functions
- finish	execute until leaving the current function
- where		show the stack
- frame N	go to the Nth stack frame
- continue	continue execution

In the window showing the source code these commands can be used to control gdb:
 `:Run` [args]	    run the program with [args] or the previous arguments
 `:Arguments` <code class="special">{args}</code>  set arguments for the next `:Run`

 `:Break`	set a breakpoint at the current line; a sign will be displayed
 `:Clear`	delete the breakpoint at the current line

 `:Step`	execute the gdb "step" command
 `:Over`	execute the gdb "next" command (`:Next` is a Vim command)
 `:Finish`	execute the gdb "finish" command
 `:Continue`	execute the gdb "continue" command
 `:Stop`	interrupt the program

If 'mouse' is set the plugin adds a window toolbar with these entries:
  Step		`:Step`
  Next		`:Over`
  Finish	`:Finish`
  Cont		`:Continue`
  Stop		`:Stop`
  Eval		`:Evaluate`
This way you can use the mouse to perform the most common commands.  You need
to have the 'mouse' option set to enable mouse clicks.

You can add the window toolbar in other windows you open with:
<code class="example">  :Winbar</code>
<code class="example"></code>
<code class="example"></code>
<code class="section">Inspecting variables </code>
							<b class="vimtag">*<a name="termdebug-variables">termdebug-variables</a>*</b>
 `:Evaluate`	    evaluate the expression under the cursor
 `K`		    same
 `:Evaluate` <code class="special">{expr}</code>   evaluate <code class="special">{expr}</code>
 `:'<code class="special">&lt;,'&gt;</code>Evaluate`     evaluate the Visually selected text

This is similar to using "print" in the gdb window.
You can usually shorten `:Evaluate` to `:Ev`.


<code class="section">Other commands </code>
							<b class="vimtag">*<a name="termdebug-commands">termdebug-commands</a>*</b>
 :Gdb	       jump to the gdb window
 :Program      jump to the window with the running program


<code class="section">Communication </code>
						<b class="vimtag">*<a name="termdebug-communication">termdebug-communication</a>*</b>
There is another, hidden, buffer, which is used for Vim to communicate with
gdb.  The buffer name is "gdb communication".  Do not delete this buffer, it
will break the debugger.


<code class="section">Customizing </code>

GDB command						 <b class="vimtag">*<a name="termdebug-customizing">termdebug-customizing</a>*</b>

To change the name of the gdb command, set the "termdebugger" variable before
invoking `:Termdebug`:
<code class="example">	let termdebugger = "mygdb"</code>
							<b class="vimtag">*<a name="gdb-version">gdb-version</a>*</b>
Only debuggers fully compatible with gdb will work.  Vim uses the GDB/MI
interface.  This probably requires gdb version 7.12.  if you get this error:
<code class="section">	Undefined command: "new-ui". Try "help".</code>
Then your gdb is too old.


Colors						<b class="vimtag">*<a name="hl-debugPC">hl-debugPC</a>*</b> <b class="vimtag">*<a name="hl-debugBreakpoint">hl-debugBreakpoint</a>*</b>

The color of the signs can be adjusted with these highlight groups:
- debugPC		the current position
- debugBreakpoint	a breakpoint

The defaults are, when 'background' is "light":
  hi debugPC term=reverse ctermbg=lightblue guibg=lightblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red

When 'background' is "dark":
  hi debugPC term=reverse ctermbg=darkblue guibg=darkblue
  hi debugBreakpoint term=reverse ctermbg=red guibg=red


Popup menu						<b class="vimtag">*<a name="termdebug_popup">termdebug_popup</a>*</b>

By default the Termdebug plugin sets 'mousemodel' to "popup_setpos" and adds
these entries to the popup menu:
	Set breakpoint		`:Break`
	Clear breakpoint	`:Clear`
	Evaluate		`:Evaluate`
If you don't want this then disable it with:
<code class="example">	let g:termdebug_popup = 0</code>
<code class="example"></code>
<code class="example"></code>
Vim window width						<b class="vimtag">*<a name="termdebug_wide">termdebug_wide</a>*</b>

To change the width of the Vim window when debugging starts, and use a
vertical split:
<code class="example">  let g:termdebug_wide = 163</code>
This will set &amp;columns to 163 when :Termdebug is used.  The value is restored
when quitting the debugger.
If g:termdebug_wide is set and &amp;Columns is already  larger than
g:termdebug_wide then a vertical split will be used without changing &amp;columns.
Set it to 1 to get a vertical split without every changing &amp;columns (useful
for when the terminal can't be resized by Vim).



 vim:tw=78:ts=8:ft=help:norl:
</pre>
<p><i>Generated by vim2html on 04 Mar 2018 23:40:43</i></p>
</body>
</html>
